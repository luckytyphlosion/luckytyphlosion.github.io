import React from 'react';
import autoTTRecGUIWindowPng from "../images/auto-tt-recorder-gui-window.png";
import ExpandableImage from "../components/ExpandableImage";

function AutoTTRecorderGUIProj() {
  return (
    <div className="project-content">
      <h2 className="project-header">Auto-TT-Recorder GUI</h2>
      <div className="project-description">
        <ExpandableImage width="50%" fullWidth="80%" src={autoTTRecGUIWindowPng} alt="Screenshot of auto-tt-recorder-gui"/>
        <p><a target="_blank" rel="noopener noreferrer" href="https://github.com/luckytyphlosion/auto-tt-recorder-gui">GitHub link</a></p>
        <p>To ease use of Auto-TT-Recorder, I created a GUI wrapper over the program using Electron, React, TypeScript, CSS, and react-hook-form. I chose Electron as a way to learn how to use React, and for me to step out of my comfort zone in terms of programming.</p>
        <p>As the GUI was a wrapper over a command-line tool, the main design of the program was making a web form that mapped inputs to command-line parameters. Web form design principles were used in designing the form. The general design of the form is that all form inputs are organized in a grid with two columns. The first column contains a label describing the input, and the second column contains the associated input. This consistent layout means that users can simply assume that all descriptions will be on the left and all inputs will be on the right instead of needing to re-evaluate the layout for each input.</p>
        <p>Inputs of similar nature were grouped together into categories via a <code>fieldset</code> tag, which prevents users from being overwhelmed by the number of inputs. This is because the grouping allows users to break down filling out the form in macro-level steps which can then be broken down into the individual inputs. For example, one group is called <strong>Music</strong>. This conveys that all the inputs in the group are related to the output video’s music, which gives the user an idea of what inputs to expect and thus allows them to formulate ahead of time what music settings they might want.</p>
        <p>To make it easier to read through the form, all inputs were left-aligned at a fixed position in the layout, and all labels were right-aligned to said fixed position. This improves readability as there is a single point where users can focus their eyes on to be able to view each label-input pair, as opposed to unaligned labels, which would require users to continually shift their view. Right-aligned labels were chosen over top-aligned labels as top-aligned labels would take too much vertical space with the many inputs in the form.</p>
        <p>While there are many options within the command-line program, not all options are required at all. times. Some options may only be required if another option is set. For example, if the user wants the default game background music in their video, the game volume and music volume inputs are ignored. Therefore, the form is designed to only show inputs as necessary. There are two levels to this. The first level is creating different forms depending on whether they want to record with no Top 10 Leaderboard (which also has another sub-selection of where to start the recording from), with a Top 10 Leaderboard with information downloaded from the <a target="_blank" rel="noopener noreferrer" href="https://chadsoft.co.uk/time-trials/">CTGP Revolution Ghost Database</a>, or with a Top 10 Leaderboard with the leaderboard information supplied manually. The form is split between these three “timelines” as they are different enough that merging them into one single form would be too unintuitive. The second level is simply just not showing inputs that don’t need to be set if other inputs are set.</p>
        <p>In addition, the form is also broken up into three levels of complexity: Simple, Advanced, and All. These levels of complexity control what inputs are shown, and what inputs are automatically filled based on recommended values. The “Simple” form complexity only contains the bare minimum inputs and minimal customization inputs needed to successfully record a ghost. The “Advanced” form complexity displays all of the options which the majority of users will need to use, while hiding some niche or complex options which are rarely used. Finally, the “All” form complexity displays every single option which the command-line program supports, to be equivalent to using the command-line program. Having multiple levels of complexity prevents new users from being overwhelmed by the number of options, and gives users a choice as to how many inputs they want to see.</p>
        <p>Finally, error messages are displayed using live validation, more specifically “late” validation, which will display an error message after the user has unselected the input. Doing so creates a less confusing experience as the user is immediately informed of any mistakes they have made, as well as hiding the error message once the input is valid.</p>
        <p>In addition, one other feature I added was the ability to import and export templates containing specific pre-filled settings. As the program is intended to be used many times, adding in the ability to load commonly used options means that people spend less time filling out the form, therefore creating a better user experience. For maximum customizability, users are able to clear every single input, including traditionally “unclearable” inputs like radio buttons, checkboxes, and dropdowns, which are cleared via right-click. This allows users to create templates with almost all combinations of filled and unfilled inputs. For example, one might want to make a template where every option is filled except the choice between the main ghost source being from a CTGP ghost link or the raw ghost file.</p>
        <p>An additional but important technical detail relates to how the command line program (Auto-TT-Recorder) is run from the GUI. It should be possible to terminate Auto-TT-Recorder from the GUI itself, as well as having it automatically close if the GUI is closed. There is another additional problem, which is that Auto-TT-Recorder will spawn processes itself, namely the Wii emulator <a target="_blank" rel="noopener noreferrer" href="https://dolphin-emu.org/">Dolphin</a> as well as <a target="_blank" rel="noopener noreferrer" href="https://ffmpeg.org/">FFmpeg and FFprobe</a> for encoding. If the GUI was closed, then Auto-TT-Recorder would be terminated, but the processes spawned by Auto-TT-Recorder would continue to run, possibly without the user knowing. In order to resolve this problem, the way that Auto-TT-Recorder spawned processes had to be rewritten. Instead of just running the executable via subprocess, I used a Python library allowing me to spawn processes using the Windows API itself, which allowed me to spawn a process in a way that it would terminate if the parent (i.e. Auto-TT-Recorder) was terminated.</p>
      </div>
    </div>
  );
}

export default AutoTTRecorderGUIProj;
